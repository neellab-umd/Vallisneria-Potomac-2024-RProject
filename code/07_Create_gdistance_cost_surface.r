## Author: Maile Neel
## 2024

## Usage ----

## This script creates the transition matrix needed to calculate cost distances through water for the samples in the Potomac River. It is designed to use within an RProject called Potomac.Manuscript.2024.R.Project.Rproj in which the script is in a subfolder named code, the input tifs are in a "raw_rasters" subfolder, the custom functions are in "functions", shapefiles are in "./data/spatial.data/", point data are in "data", processed rasters go in "processed_rasters", and the rds files are placed in "cost_surfaces".

## If tr1_Potomac_10 and tr1c_Potomac_10 exist in the cost surfaces directory you do not need to run this script again. These transition matrices are used in the scripts 8A_Calculate_Sample_Distances.R and 9A_Calculate_Site_Water_Distances.r.

## Outline of Steps ----
## 1. Load packages and source the custom functions.
## 2. Bring in tifs of water at the desired cell size. This will be a balance of accuracy of small cell sizes and the memory the calculations require. 
## 3. Trim tiffs to get rid of areas you do not need so you can save on memory.
## 4. Correct the tifs to ensure that the conversion from polygon to grid at each cell size did not place the sample location points or site centroids you will use to calculate cost distance outside of water.
## 5. Create the transition matrices from the corrected tifs.
## 6. Output the transition matrices to RDS files so you can use them for future analysis - that way you don't have to run this each time you want to calculate cost distances with gdistance.


## Before you start----
## The script requires the layers you want to use for the cost surface to be in raster format in a .tif file. To process used to create the tif in this project from from a larger shapefile in ArcGIS is as follows:
## 1) Select the part of the shapefile you want to convert to raster - in this case select by attribute for Water - Potomac from the file CB.PR.Digitized.MN.2020.shp
## 2) Right click on the name of the shapefile in the table of contents and export the selection to a new shapefile.
## 3) From the Toolbox, choose Conversion Tools, To Raster, then Polygon to Raster to create a raster. Specify the desired cell size. Make sure you start with a shapefile projected in UTM coordinates so you can set the cell size in meters.
## 4) From the Toolbox, Spatial Analyst Tools, use Reclass/Reclassify to change NAs to 0s - gdistance won't take the NA's - it wants 0's
## 5) If you need to clip extents, you can do so somewhat manually using Spatial Analyst Extract by Rectangle.
## 6) Export Tif. In table of contents, right click on the final raster, choose Data, then Export Data.  
##  Choose Tif as the file type.


#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# Install and Load Packages ----
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

if (!require("pacman")) install.packages("pacman")
pacman::p_load(here, 
               tidyverse,
               gdistance,
               terra,
               tidyterra,
               ggthemes,
               sf)

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# Source custom functions ----
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
if(!exists("trim_rasters", 
           mode="function")) source(here::here("functions", 
                                               "trim_rasters.r"))

if(!exists("put_points_in_water", 
           mode="function")) source(here::here("functions",
                                               "put_points_in_water.r"))

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# Read in and check raster ----
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Potomac10m <- terra::rast(here::here("raw_rasters","Potomac10m.tif"))

#### Do some quick checks of your data ----


#### Trim the raster ----

# In the water masks, water = 1 and land = 0. When you create a raster from a tif generated by ArcGIS, it may have lots of extra columns and rows of 0's beyond the data of interest, use this block of code to trim that out. 

## Using the procedure above (saving the selected part of the shapefile) I did not get extra columns or rows.  But this process is a helpful cleanup routine that can ensure any grid you bring in is as small as possible and it can be used to convert NA values to a value that will work within gdistance.

## The custom function trim_rasters() converts any background values that are not already NA(specified by the trimvalue argument) to NA's, removes all full rows and columns of NAs, and finally replaces all remaining NAs with the trimvalue. Save this smaller raster to a new tif that can be used for all downstream processes.

Potomac10m_trimmed <-trim_rasters(Potomac10m,
                           trimvalue = 0)

## check that the trimmed raster looks right
ggplot() + 
  geom_spatraster(data = Potomac10m_trimmed) + 
  ggtitle("Potomac Trimmed") +
  scale_fill_continuous(na.value = NA) +
  coord_sf(datum = st_crs(Potomac10m_trimmed)) +
  ggthemes::theme_map()+
  theme(legend.position = "none") +
  scale_x_continuous(expand = expansion(0)) +
  scale_y_continuous(expand = expansion(0)) 

## write out your trimmed raster ----

terra::writeRaster(Potomac10m_trimmed, 
                      here::here("processed_rasters","Potomac10m_trimmed.tif"),
                      overwrite = TRUE)

## clean up after yourself to keep from hogging memory
remove(Potomac10m)

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
## Ensure your points fall within water ----
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

## You need to make sure all your points fall within water or the cost distance analysis will fail.

### 1. Read in trimmed raster if it is not already loaded----

Potomac10m_trimmed <- terra::rast(here::here("processed_rasters","Potomac10m_trimmed.tif"))

### 2. Read in Site Points ----
## In this case the points are the sample locations used in the Potomac manuscript. 

Potomac_Sites <- readr::read_csv(here::here("data",
                                     "PR.Pop.Centroids.UTMs.csv")) %>% 
  rename(Pop = NewPop)

####2a. Convert to sf object and project ----

## We project the points into UTM with the NAD83 datum (epsg:26918) so that the points are in the same projection as our water tif  Using the Cartesian UTM system gets us accurate distance measurements in meters

Potomac_Sites.sf.utm <- Potomac_Sites %>% 
  st_as_sf(                   #convert the points to an sf object
    coords=c("X", 
             "Y"),
    agr = "constant",
    crs = 26918,               #project to UTM NAD83
    stringsAsFactors = FALSE,
    remove = TRUE
  ) 

#### 2b. Optionally Plot Sites and Water ---- 

## Optional plot of site points with the water raster for a quick check. This step is not needed for the next steps, it is just here to let you check that the points and raster are read in and projected correctly.

ggplot() + 
  geom_spatraster(data = Potomac10m_trimmed) + 
  ggtitle("Watermask with Sites") + 
  geom_sf(data = Potomac_Sites.sf.utm,
          size = 2, 
          color = "magenta") +
  scale_fill_continuous(na.value = NA) +
  coord_sf(datum = st_crs(Potomac_Sites.sf.utm)) +
  ggthemes::theme_map()+
  theme(legend.position = "none") +
  scale_x_continuous(expand = expansion(0)) +
  scale_y_continuous(expand = expansion(0)) 
 

### 3. Read in Sample Points ----

Potomac_Samples <- read.csv(here::here("data",
                                 "allpotomac.microsatellite.data.csv")) %>% 
  dplyr::filter(Clone.ID.2018 != "NA") %>% 
  dplyr::select(IDName,NewPop,OrderPop,Clone.ID.2018,Longitude,Latitude, X, Y) %>% 
  rename(Pop = NewPop)

## Project the points into UTM with the NAD83 datum (epsg:26918) so that the points are in the same projection as our water tif. Using the Cartesian UTM system gets us accurate distance measurements.

####3a. Convert to sf object and project ----

Potomac_Samples.sf.utm <- Potomac_Samples %>% 
  st_as_sf(                   #convert the points to an sf object
    coords=c("X", 
             "Y"),
    agr = "constant",
    crs = 26918,               #project to UTM NAD83
    stringsAsFactors = FALSE,
    remove = TRUE
  ) 

###4. Intersect the points with rasters ----

## Intersect the points with the 10 m raster to determine if they all fall within the raster representation of the water shapefile. They may fall outside due to error imposed by converting to raster cells or calculating centroids. Points that fall inside at one resolution can fall outside at a different resolutions so you need to check this for the cell size you plan to use.

## Points will have a value of 0 if they do not intersect and 1 if they do.

Site.points.in.and.out.of.water <- 
  terra::extract(Potomac10m_trimmed,  # raster layer
  Potomac_Sites.sf.utm,  # sf with centroids for buffer
  method = "simple")  %>% 
  dplyr::filter(Potomac10m == 0)

Sample.points.in.and.out.of.water <- 
  terra::extract(Potomac10m_trimmed,  # raster layer
  Potomac_Samples.sf.utm, # sf with centroids for buffer
  method = "simple"
)  %>% filter(Potomac10m == 0)


###5. Force Raster to Include Points ----

## Apply our custom function to fix the raster for both sample and site points.

Potomac10m_1 <- put_points_in_water(input_raster = Potomac10m_trimmed, 
                                    input_points =  Potomac_Sites.sf.utm, field = "Pop")

Potomac10m_1 <- put_points_in_water(input_raster = Potomac10m_1, 
                                    input_points =Potomac_Samples.sf.utm, field = "Pop")

###6. Confirm all Points are in Water after correcting ----

Site.points.in.and.out.of.water.corrected.grid <- terra::extract(
  Potomac10m_1,  # raster layer
  Potomac_Sites.sf.utm,  # sf with centroids for buffer
  method = "simple") %>%  
  filter(Potomac10m == 0)

Sample.points.in.and.out.of.water.corrected.grid <- terra::extract(
  Potomac10m_1,  # raster layer
  Potomac_Samples.sf.utm,  # sf with centroids for buffer
  method = "simple") %>% 
  filter(Potomac10m == 0)

### 7. Write out Corrected Raster ----

## Write out raster that is corrected to intersect all sample points and site centroids so you do not have to do all the corrections again if you want to create another transition matrix.  

terra::writeRaster(Potomac10m_1, 
                   here::here("processed_rasters","Potomac10m_corrected.tif"),
                   overwrite = TRUE)

## Generate transition matrix ----

### Read in corrected rater if it is not already in your environment.

Potomac10m_1 <- terra::rast(here::here("processed_rasters","Potomac10m_corrected.tif"))

## Create a TransitionLayer for the corrected, trimmed raster based the values contained in the original raster.  In this case we take the minimum of the values of each cell compared with each of the 8 neighboring cells. Given that all water values are 1, this yields 1 for the transition between water cells and 0 if either of the cells is land.

## You will need to be using 64 bit r to have any hope of getting this to work.

## gdistance uses RasterLayers and RasterBricks.  You need to convert from a terra SpatRaster.

tr1_Potomac_10 <- gdistance::transition(as(Potomac10m_1, "Raster"), 
                          transitionFunction=min, 
                          directions=8)


## inspect the transitionLayer and see that the object keeps much
## information from the original RasterLayer object

tr1_Potomac_10

## the class dsCMatrix is symmetric and contains only one triangle of the matrix

class(transitionMatrix(tr1_Potomac_10))

## geocorrection type = C corrects for different distances of diagonal versus edge to edge connection. Diagonal neighbours are more remote(sqrt(2) from each other than orthogonal neighbors. Also, on equirectangular (longitude-latitude) grids, West-East connections are longer at the equator and become shorter towards the poles as the meridians approach each other. matrix need to be corrected for these two types of distance distortion. Both types of distortion are corrected by dividing each conductance matrix value by the distance between cell centers in a type C correction.

## You can also make corrections to account for the fact that the cells closer to the poles are slightly larger than the cells towards the poles (type = r) when the coordinate system is latlong. This correction weights the probability of reaching an adjacent cell in a random walk proportional to the surface covered by the cell.The N-S correction is made by multiplying the transition values with the cosine of the average latitude of the cell centers.  Not needed here with UTM data.  When type is set to "r" the function geoCorrection  Computationally, the function corrects the surface distortion by multiplying the North-South transition values with the cosine of the average latitude of the two cell centers that are being connected.

## Want scl set to false to get accurate distances.

tr1c_Potomac_10 <- geoCorrection(tr1_Potomac_10, 
                             type = "c", 
                             multpl = FALSE, 
                             scl = FALSE)

## Save the transition matrices ----

### Once this script has been run, the transition matrix is available to be used in the scripts 8A_Calculate_Sample_Distances.R and 9A_Calculate_Site_Water_Distances.r. It does not have to be re-created.

saveRDS(tr1_Potomac_10,here::here("cost_surfaces", "tr1.Potomac.Transition.10m.rds"))

saveRDS(tr1c_Potomac_10,here::here("cost_surfaces", "tr1c.Potomac.Transition.10m.rds"))

